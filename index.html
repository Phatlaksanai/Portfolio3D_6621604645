<!DOCTYPE html>
<html>

<head>
    <title>Portfolio3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <!-- core three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>

    <script>

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // ✅ เปิดใช้งานเงา!
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();

        // ✅ กล้อง
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        // camera.position.set(0, 10, 7);
        // camera.lookAt(0, 0, 0); // -5, 1, -1, 0, 5, 6
        let pickedObjPosition = new THREE.Vector3(-2, 2, 0); // ตัวแปรเก็บตำแหน่งกล้อง
        let cameraPosition = new THREE.Vector3(-2, 5, 12); // ตัวแปรเก็บตำแหน่งกล้อง
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0.5, 0);
        controls.enableDamping = true;

        const AmbientLight = new THREE.AmbientLight(0x454040); // แสงสว่างทั่วไป
        scene.add(AmbientLight);

        const directionalLight = new THREE.DirectionalLight(0xffeedd, 2);
        directionalLight.position.set(10, 5, 10);
        directionalLight.castShadow = true; // ✅ เปิดใช้งานเงา
        scene.add(directionalLight);
        // const directionalLightHelper = new THREE.DirectionalLightHelper(directionalLight, 1);
        // scene.add(directionalLightHelper);

        const pointlight1 = new THREE.PointLight(0xffffff, 5, 5);
        pointlight1.position.set(0, 3, 5);
        // pointlight1.castShadow = true; // ✅ เปิดใช้งานเงา
        scene.add(pointlight1);
        // const pointLight1Helper = new THREE.PointLightHelper(pointlight1, 0.2);
        // scene.add(pointLight1Helper);

        const pointlight3 = new THREE.PointLight(0xffffff, 3, 3);
        pointlight3.position.set(1, 2, -1);
        // pointlight3.castShadow = true; // ✅ เปิดใช้งานเงา
        scene.add(pointlight3);
        // const pointLight3Helper = new THREE.PointLightHelper(pointlight3, 0.2);
        // scene.add(pointLight3Helper);

        const pointlight2 = new THREE.PointLight(0xffffff, 5, 6);  // ความสว่าง, ระยะ
        pointlight2.position.set(-2, 4, 2);
        // pointlight2.castShadow = true; // ✅ เปิดใช้งานเงา
        scene.add(pointlight2);
        // const pointLight2Helper = new THREE.PointLightHelper(pointlight2, 0.2);
        // scene.add(pointLight2Helper);

        //✅ พื้น
        const planeGeometry = new THREE.PlaneGeometry(10, 10);
        const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2; // หมุนให้เป็นพื้น
        plane.position.set(-2, 0, 2);
        plane.receiveShadow = true; // ✅ พื้นรับเงา
        scene.add(plane);

        const tex1 = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Phatlaksanai/phatlaksanai.github.io/refs/heads/main/concrete_floor_damaged_01_diff_1k.jpg', t => {
            t.wrapS = THREE.RepeatWrapping;
            t.wrapT = THREE.RepeatWrapping;
        });

        const mat1 = new THREE.MeshStandardMaterial({
            //color: 0xffffff,
            map: tex1
        });

        const floorGeom = new THREE.PlaneGeometry(10, 10);
        const floorMesh = new THREE.Mesh(floorGeom, mat1);
        floorMesh.rotation.x = -Math.PI / 2; // หมุนพื้นให้ขนตรง
        floorMesh.position.set(-2, 0, 2);
        floorMesh.receiveShadow = true; // ✅ วัตถุนี้รับเงา
        scene.add(floorMesh);

        const loader = new THREE.GLTFLoader();

        loader.load('https://phatlaksanai.github.io/hook2.glb', function (gltf) {
            const object = gltf.scene;
            object.traverse(function (child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            object.position.set(-2, 0, 2);
            scene.add(object);
        }, undefined, function (error) {
            console.error('Error loading GLTF:', error);
        });

        loader.load('https://phatlaksanai.github.io/xeno.glb', function (gltf) {
            const object = gltf.scene;
            object.traverse(function (child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            object.position.set(-2, 0, 2);
            scene.add(object);
        }, undefined, function (error) {
            console.error('Error loading GLTF:', error);
        });
        loader.load('https://phatlaksanai.github.io/home2.glb', function (gltf) {
            const object = gltf.scene;
            object.traverse(function (child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            object.position.set(-2, 0, 2);
            scene.add(object);
        }, undefined, function (error) {
            console.error('Error loading GLTF:', error);
        });
        loader.load('https://phatlaksanai.github.io/nisitpic.glb', function (gltf) {
            const object = gltf.scene;
            object.traverse(function (child) {
                if (child.isMesh) {
                    //child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            object.position.set(-2, 0, 2);
            scene.add(object);
        }, undefined, function (error) {
            console.error('Error loading GLTF:', error);
        });
        loader.load('https://phatlaksanai.github.io/thelastestsign.glb', function (gltf) {
            const object = gltf.scene;
            object.traverse(function (child) {
                if (child.isMesh) {
                    //child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            object.position.set(-2, 0, 2);
            scene.add(object);
        }, undefined, function (error) {
            console.error('Error loading GLTF:', error);
        });

        const clickable = []; // เก็บเฉพาะ object ที่ต้องการให้คลิกได้

        const buttonUniforms = {// Cell Shader 
            uTime: { value: 0.0 },
            uLightDir: { value: new THREE.Vector3(0.4, 1.0, 0.8).normalize() },
            uTex: {
                value: new THREE.TextureLoader().load(
                    "https://th.bing.com/th/id/R.7c039f1f5011beb8748fe708affa1994?rik=BBcM1h5lbRbrjg&pid=ImgRaw&r=0" 
                )
            }
        };

        const buttonVert = `
  uniform float uTime;
  varying vec3 vNormal;
  varying vec3 vPosW;
  varying vec2 vuv;

  void main() {
    vNormal = normalize(mat3(modelMatrix) * normal);
    vec3 pos = position;
    vuv = uv;
    vPosW = (modelMatrix * vec4(pos, 1.0)).xyz;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
`;

        const buttonFrag = `
  precision mediump float;
  varying vec3 vNormal;
  uniform vec3 uLightDir;
  varying vec3 vPosW;
  varying vec2 vuv;
  uniform sampler2D uTex;

  void main() {
    float diffuse = clamp(dot(vNormal, uLightDir), 0.0, 1.0);
    float levels = 5.0;                        
    diffuse   = floor(diffuse * levels) / levels;
    diffuse += 0.6;

    vec3 R = reflect(-uLightDir, vNormal);
    vec3 V = normalize(cameraPosition - vPosW);
    float specular = max(pow(dot(R, V), 8.0), 0.0);
    specular = clamp(smoothstep(0.4, 0.6, specular),0.0,1.0);

    if(diffuse <= 0.6) 
      specular = 0.0;

    vec3 base = texture2D(uTex, vuv).rgb; 
    vec3 ambient = vec3(0.3);       
    vec3 color = (base * diffuse) + specular + ambient;
    gl_FragColor = vec4(color, 1.0);
  }
`;

        function addObj(mesh, pos, name) {
            mesh.material = new THREE.ShaderMaterial({
                vertexShader: buttonVert,
                fragmentShader: buttonFrag,
                uniforms: buttonUniforms,
                side: THREE.DoubleSide
            });
            mesh.position.copy(pos);
            mesh.name = name;
            scene.add(mesh);
            clickable.push(mesh);
            return mesh;
        }

        const pic = addObj(
            new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshBasicMaterial({ color: 0xff6b6b })),
            new THREE.Vector3(-2.2, 1.5, 6.6),
            'Pic'
        );
        pic.rotation.y = -Math.PI * 0.5; 
        const meme = addObj(
            new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshBasicMaterial({ color: 0x00FF7F })),
            new THREE.Vector3(-2.2, 4.5, 6.6),
            'meme'
        );
        meme.rotation.y = -Math.PI * 0.5;
        const Homepic = addObj(
            new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff })),
            new THREE.Vector3(-2, 3.5, -2.4),
            'Homepic'
        );
        Homepic.rotation.y = -Math.PI * 0.5;
        const NextDetailNisit = addObj(
            new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff })),
            new THREE.Vector3(-2, 2.2, -2.4),
            'NextDetailNisit'
        );
        NextDetailNisit.rotation.y = -Math.PI * 0.5;
        const Homememe = addObj(
            new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff })),
            new THREE.Vector3(-6.3, 1.6, 2),
            'Homememe'
        );
        Homememe.rotation.y = -Math.PI * 0;
        const BackDetailNisit = addObj(
            new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff })),
            new THREE.Vector3(2.4, 1.1, 5),
            'BackDetailNisit'
        );
        BackDetailNisit.rotation.y = Math.PI;
        const alien = addObj(
            new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshBasicMaterial({ color: 0x87CEFA })),
            new THREE.Vector3(-2.2, 3, 6.6),
            'alien'
        );
        alien.rotation.y = -Math.PI * 0.5;
        const Homealien = addObj(
            new THREE.Mesh(new THREE.SphereGeometry(0.15, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff })),
            new THREE.Vector3(-1.3, 0.1, 1.8),
            'Homealien'
        );
        Homealien.rotation.z = Math.PI * 0.75;
        const Nextalien = addObj(
            new THREE.Mesh(new THREE.SphereGeometry(0.15, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff })),
            new THREE.Vector3(-1.3, 0.1, 0.5),
            'Nextalien'
        );
        Nextalien.rotation.z = Math.PI * 0.75;
        const backalien = addObj(
            new THREE.Mesh(new THREE.SphereGeometry(0.15, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff })),
            new THREE.Vector3(-4.5, 0.1, 0.6),
            'backalien'
        );
        backalien.rotation.z = Math.PI * 0.5;
        backalien.rotation.y = -Math.PI * 0.5;
        const NextCredit = addObj(
            new THREE.Mesh(new THREE.SphereGeometry(0.15, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff })),
            new THREE.Vector3(-4.5, 0.1, 0.0),
            'NextCredit'
        );
        NextCredit.rotation.z = Math.PI * 0.5;
        NextCredit.rotation.y = -Math.PI * 0.5;


        const VIEWS = { //  pos ตำแหน่งตั้งกล้อง, tar ตำแหน่งที่กล้องมอง
            Pic: { pos: new THREE.Vector3(-1.5, 4, 0.0), tar: new THREE.Vector3(0.0, 2, -5.0) },
            Homepic: { pos: new THREE.Vector3(-2.0, 5, 12), tar: new THREE.Vector3(-2, 2, 0) },
            meme: { pos: new THREE.Vector3(-2, 4, 3), tar: new THREE.Vector3(-7, 3.5, 3) },
            Homememe: { pos: new THREE.Vector3(-2.0, 5, 12), tar: new THREE.Vector3(-2, 2, 0) },
            alien: { pos: new THREE.Vector3(-3, 1, 1), tar: new THREE.Vector3(4, 1, 1) },
            Homealien: { pos: new THREE.Vector3(-2.0, 5, 12), tar: new THREE.Vector3(-2, 2, 0) },
            Nextalien: { pos: new THREE.Vector3(-5.0, 3.3, 1), tar: new THREE.Vector3(-5.0, 2, 0) },
            backalien: { pos: new THREE.Vector3(-3, 1, 1), tar: new THREE.Vector3(4, 1, 1) },
            NextDetailNisit: { pos: new THREE.Vector3(0.0, 3.0, 5), tar: new THREE.Vector3(10.0, 1, 3) },
            BackDetailNisit: { pos: new THREE.Vector3(-1.5, 4, 0.0), tar: new THREE.Vector3(0.0, 2, -5.0) },
            NextCredit: { pos: new THREE.Vector3(-2, 10, 2), tar: new THREE.Vector3(0, 20, 0) },
        };
        //let cameraPosition = VIEWS['Sphere'].pos;
        // --- Raycaster + คลิกเพื่อสลับมุม ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function setPointer(e) {
            const r = renderer.domElement.getBoundingClientRect();
            const x = (e.clientX ?? e.touches[0].clientX) - r.left;
            const y = (e.clientY ?? e.touches[0].clientY) - r.top;
            pointer.x = (x / r.width) * 2 - 1;
            pointer.y = -(y / r.height) * 2 + 1;
        }

        function onPick(e) {
            setPointer(e);
            raycaster.setFromCamera(pointer, camera);
            const hit = raycaster.intersectObjects(clickable, false)[0];
            if (!hit) return;
            const view = VIEWS[hit.object.name];
            cameraPosition = view.pos;
            pickedObjPosition = view.tar;
            // pickedObjPosition = hit.object.position;
            if (!view) return;

            // camera.position.copy(view.pos);
            // controls.target.copy(view.tar);
            controls.update();
        }

        renderer.domElement.addEventListener('click', onPick);
        renderer.domElement.addEventListener('touchend', (e) => { onPick(e); }, { passive: true });

        // --- Resize ---
        addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });

        function lerp(a, b, t) {
            return a + (b - a) * t;   // t ใน [0..1]
        } // สูตรหาค่าระหว่างจุด 2 จุด

        let t = 0; // ตัวแปรเวลา
        let cylinderTarget = new THREE.Vector3();

        const flagUniforms = {
            uTime: { value: 0.0 },
            uLightDir: { value: new THREE.Vector3(0.4, 1.0, 0.8).normalize() },
            uTex: { value: new THREE.TextureLoader().load('https://tse1.mm.bing.net/th/id/OIP.ar69BsRNqg80fBtNeZUUHwHaEc?rs=1&pid=ImgDetMain&o=7&rm=3') }
        };


        const flagVert = `
    uniform float uTime;
    varying vec2 vUv;
    void main(){
        vUv = uv;
        vec3 pos = position;

        // ทำให้ธงโบกสะบัด
        pos.z += sin(pos.x * 2.0 + uTime * 4.0) * 0.1;
        pos.y += sin(pos.x * 2.0 + uTime * 4.0) * 0.05;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
    }
`;

        const flagFrag = `
    precision mediump float;
    varying vec2 vUv;
    uniform sampler2D uTex;
    void main() {
        vec3 base = texture2D(uTex, vUv).rgb;
        gl_FragColor = vec4(base, 1.0);
    }
`;
        const flagGeo = new THREE.PlaneBufferGeometry(2.0, 1.5, 32, 32);
        const flagMat = new THREE.ShaderMaterial({
            vertexShader: flagVert,
            fragmentShader: flagFrag,
            uniforms: flagUniforms,
            side: THREE.DoubleSide
        });

        const flagMesh = new THREE.Mesh(flagGeo, flagMat);
        flagMesh.position.set(0.0, 5.0, 6.7);
        flagMesh.rotation.y = Math.PI * 0.0;
        scene.add(flagMesh);
        const bozo = new THREE.TextureLoader().load(
            "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSbXGWUbr4_2jeJ6olsx5n2r7B7EED9SdDjHA&s"
        );

        const bozoFlagMat = flagMat.clone();
        bozoFlagMat.uniforms = {
            ...flagMat.uniforms,
            uTex: { value: bozo }
        };
        const bozoFlag = new THREE.Mesh(flagGeo, bozoFlagMat);
        bozoFlag.position.set(-6.2, 3.0, 1.2);
        bozoFlag.rotation.y = Math.PI / 2;
        scene.add(bozoFlag);

        const micheal = new THREE.TextureLoader().load(
            "https://us.v-cdn.net/6030815/uploads/IFDHTQV8WCAS/picsart-06-05-08-44-04.jpg"
        );

        const michealFlagMat = flagMat.clone();
        michealFlagMat.uniforms = {
            ...flagMat.uniforms,
            uTex: { value: micheal }
        };
        const michealFlag = new THREE.Mesh(flagGeo, michealFlagMat);
        michealFlag.position.set(-6.2, 3.0, 4);
        michealFlag.rotation.y = Math.PI / 2;
        scene.add(michealFlag);

        const doctor = new THREE.TextureLoader().load(
            "https://i.ytimg.com/vi/-ZRLokOnXKc/hq720.jpg?sqp=-oaymwEhCK4FEIIDSFryq4qpAxMIARUAAAAAGAElAADIQj0AgKJD&rs=AOn4CLB3UpIslX22T9DKA8OYf2cDuTPbDw"
        );

        const doctorFlagMat = flagMat.clone();
        doctorFlagMat.uniforms = {
            ...flagMat.uniforms,
            uTex: { value: doctor }
        };
        const doctorFlag = new THREE.Mesh(flagGeo, doctorFlagMat);
        doctorFlag.position.set(-6.2, 5.0, 4);
        doctorFlag.rotation.y = Math.PI / 2;
        scene.add(doctorFlag);

        const steve = new THREE.TextureLoader().load(
            "https://i.ytimg.com/vi/Z02s-QIOrtk/hq720.jpg?sqp=-oaymwEhCK4FEIIDSFryq4qpAxMIARUAAAAAGAElAADIQj0AgKJD&rs=AOn4CLCOEKXleyRAksapyIeaNhpeOLgvSg"
        );
        const steveFlagMat = flagMat.clone();
        steveFlagMat.uniforms = {
            ...flagMat.uniforms,
            uTex: { value: steve }
        };

        const steveFlag = new THREE.Mesh(flagGeo, steveFlagMat);
        steveFlag.position.set(-6.2, 5.0, 1.2);
        steveFlag.rotation.y = Math.PI / 2;
        scene.add(steveFlag);

        function loop() {
            t += 0.02;
            flagUniforms.uTime.value = performance.now() / 1000;
            buttonUniforms.uTime.value = performance.now() / 1000;
            buttonUniforms.uLightDir.value.set(
                Math.sin(performance.now() / 1000) * 2.0,
                1.0,
                0.8
            ).normalize();

            controls.update();
            controls.target.lerp(pickedObjPosition, 0.02);
            camera.position.lerp(cameraPosition, 0.02);
            renderer.render(scene, camera);
            requestAnimationFrame(loop);
        }

        loop();
        window.addEventListener('keydown', (event) => {
        });

    </script>
</body>

</html>